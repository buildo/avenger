requisiti alto livello
- creare queries (con query*, compose, product) e possibili diverse strategie
- osservare una query e ricevere aggiornamenti (success, fail), da solo nel mondo
- osservare una query e reagire al fatto che altri la richiedono pi√π in la nel tempo
- osservare parte di una query (di una comp, prodotto) e ricevere aggiornamenti quando ci sono eventi che riguardano l'intera (compo, prodotto)
- viceversa, osservare intera (comp, prodotto) e ricevere aggiornamenti quando ci sono eventi che riguardano una parte
- invalidare una Query


Query(dato un input fisso, che decidiamo essere non un primitive type)
assi:
    - cached/composition/product
    - 3 strategies...
    - run/invalidate

- cached
  - refetch
    - run()
      - viene chiamata una volta la fetch e run torna il risultato successful
      - viene chiamata una volta una fetch che fallisce sempre e run ritorna il fallimento
      - dopo avere eseguito run con successo una volta, viene chiamata di nuovo run e la fetch esegue nuovamente
      - dopo avere eseguito run con fallimento una volta, viene chiamata di nuovo run e la fetch esegue nuovamente
  - available
    - run()
      - viene chiamata una volta la fetch e run torna il risultato successful
      - viene chiamata una volta una fetch che fallisce sempre e run ritorna il fallimento
      - dopo avere eseguito run con successo una volta, viene chiamata di nuovo run e la fetch NON esegue
      - dopo avere eseguito run con fallimento una volta, viene chiamata di nuovo run e la fetch esegue nuovamente
  - expire(ms)
    - run()
      - viene chiamata una volta la fetch e run torna il risultato successful
      - viene chiamata una volta una fetch che fallisce sempre e run ritorna il fallimento
      - dopo avere eseguito run con successo una volta, viene chiamata di nuovo run prima che siano passati `ms` e la fetch NON esegue
      - dopo avere eseguito run con successo una volta, viene chiamata di nuovo run dopo che sono passati `ms` e la fetch esegue nuovamente
      - dopo avere eseguito run con fallimento una volta, viene chiamata di nuovo run prima che siano passati `ms` e la fetch esegue nuovamente
      - dopo avere eseguito run con fallimento una volta, viene chiamata di nuovo run dopo che sono passati `ms` e la fetch esegue nuovamente
- compose
  - refetch
    - run()
      - viene chiamata una volta la fetch di master e una volta la fetch di slave, e viene ritornato il risultato successful di slave
      - viene chiamata una volta la fetch di master che fallisce sempre, NON viene chiamata la fetch di slave, e viene ritornato il fallimento di master
      - viene chiamata una volta la fetch di master che ha success, viene chiamata una volta la fetch di slave che fallisce sempre, e viene ritornato il fallimento di slave
      - dopo avere eseguito run con successo una volta,
        si fa run() nuovamente e viene chiamata una volta la fetch di master e una volta la fetch di slave, e viene ritornato il risultato successful di slave
      - dopo aver eseguito run con fallimento di master una volta,
        si fa run() nuovamente e viene chiamata una volta la fetch di master che fallisce sempre,
        NON viene chiamata la fetch di slave, e viene ritornato il fallimento di master
      - dopo aver eseguito run con fallimento di master una volta,
        si fa run() nuovamente e viene chiamata una volta la fetch di master che ha successo,
        viene chiamata la fetch di slave che fallisce sempre, e viene ritornato il fallimento di slave
      - dopo aver eseguito run con fallimento di slave una volta,
        si fa run() nuovamente e viene chiamata una volta la fetch di master che fallisce sempre,
        NON viene chiamata la fetch di slave, e viene ritornato il fallimento di master
      - dopo aver eseguito run con fallimento di slave una volta,
        si fa run() nuovamente e viene chiamata una volta la fetch di master che ha successo,
        viene chiamata la fetch di slave che fallisce sempre, e viene ritornato il fallimento di slave
  - available
    - run()
      - viene chiamata una volta la fetch di master e una volta la fetch di slave, e viene ritornato il risultato successful di slave
      - viene chiamata una volta la fetch di master che fallisce sempre, NON viene chiamata la fetch di slave, e viene ritornato il fallimento di master
      - viene chiamata una volta la fetch di master che ha success, viene chiamata una volta la fetch di slave che fallisce sempre, e viene ritornato il fallimento di slave
      - dopo avere eseguito run con successo una volta,
        si fa run() nuovamente e NON viene chiamata la fetch di master e NON viene chiamata la fetch di slave, e viene ritornato il precedente risultato successful di slave
      - dopo aver eseguito run con fallimento di master una volta,
        si fa run() nuovamente e viene chiamata una volta la fetch di master che fallisce sempre,
        NON viene chiamata la fetch di slave, e viene ritornato il fallimento di master
      - dopo aver eseguito run con fallimento di master una volta,
        si fa run() nuovamente e viene chiamata una volta la fetch di master che ha successo,
        viene chiamata la fetch di slave che fallisce sempre, e viene ritornato il fallimento di slave
      - dopo aver eseguito run con fallimento di slave una volta,
        si fa run() nuovamente e NON viene chiamata la fetch di master,
        viene chiamata la fetch di slave, e viene ritornato il success di slave
      - dopo aver eseguito run con fallimento di slave una volta,
        si fa run() nuovamente e NON viene chiamata la fetch di master,
        viene chiamata la fetch di slave che fallisce sempre, e viene ritornato il fallimento di slave

TODO:
    - expire(ms)
  - product
    - refetch
    - available
    - expire(ms)
- run() chiamato in sequenza senza await NON causa multiple fetch


observe
- 
invalidate